\chapter{Centralized control}\label{ch:centralized-control}

As opposed of the decentralized approach where each joint is controlled independently of each others, we can implement a control law based on \textbf{centralized approach}\index{centralized control approach} where the manipulator is controlled exploiting its overall model.
This approach required obviously a model of the robot, but it generally guarantees better performance than the decentralized one.

\begin{nb}as we saw in \autoref{sec:simplified-dynamic-model} for a \textbf{decentralized} control we stated that a high reduction ratios in transmissions between motors and joints is a fundamental requirement because this reduces the magnitude of the noise $\vect d$, if this decoupling effect is not guaranteed we must use the \textbf{centralized} approach.\end{nb}

The \textbf{centralized control approach} allows us to develop several control schemes both in the joint space that in the operational one.

\section{Control in joint space}

In joint space control the design of the controller is done directly on the joints state.

\subsection{Open loop}

A first naive approach can be seen as an extension of a \textbf{decentralized controller} designed in the previous chapter.

The idea is to compensate the noise $\vect d$ adding to the decentralized scheme an open loop controller fed with the desired joints functions $\qd, \dqd, \ddqd$.
Yuo can see the scheme in \autoref{fig:open-loop}.

The function of the feedforward controller can be designed from \autoref{eq:decentralized-noise} using as input the desired state

\[
	\hat{\vect d} = \matr N^{-1} \matr{\Delta B}(\qd) \matr N^{-1} \ddqd_m +\matr N^{-1} \matr{C}(\qd,\dqd) \matr N^{-1} \dqd_m + \matr N^{-1} \vect{g}(\qd)
\]

The calculation of $\hat{\vect d}$ is generally computationally expensive, so it is preferred to precalculate it offline $\hat{\vect d}$ if it is possible (i.e in the repeated trajectories).

\begin{figure}[htb]
	\centering
	\resizebox{\textwidth}{!}{
	\begin{tikzpicture}
		\node [input] (iq_d) {};
		\node [sum, right= 1cm of iq_d] (sum_e) {};
		\node [block, right=0.6cm of sum_e, text width=2.3cm] (controller) {Decentralized\\controller};
		\node [block, above=1cm of controller, text width=2cm, minimum height=1.5cm] (controller_ff) {Centralized feedforward action};
		\node [sum, right=0.6cm of controller] (sum_dd) {};
		\node [input] at ([yshift=-0.0cm] 0,0 |- controller_ff) (dq_d) {};
		\node [input] at ([yshift=0.6cm] 0,0 |- controller_ff) (ddq_d) {};

		\node [sum, right=1cm of sum_dd] (sum_i) {};
		\node [sum, right=0.6cm of sum_i] (sum_f) {};
		\node [block, right=0.6cm of sum_f] (inertial) {$\left(\matr J_m + \bar{\matr B}_r \right)^{-1}$};
		\node [block, below=0.5cm of inertial] (dq2f) {$\matr D_m$};
		\node [integrator, right=1cm of inertial] (ddq2dq) {};
		\node [integrator, right=1cm of ddq2dq] (dq2q) {};
		\node [output, right=1cm of dq2q] (output) {};
		\node [block, above=0.5cm of inertial] (d_b) {$\matr N^{-1} \matr{\Delta B}(\q) \matr N^{-1}$};
		\node [block, above=0.3cm of d_b] (d_c) {$\matr N^{-1} \matr{C}(\q,\dq) \matr N^{-1}$};
		\node [block, above=0.3cm of d_c] (d_g) {$\matr N^{-1} \vect{g}(\q)$};
		\node [sum] (sum_d) at (sum_i |- d_b) {};

		\draw [->] (sum_dd) -- node {$\vect \tau_m$} (sum_i);
		\draw [->] (sum_i) -- (sum_f);
		\draw [->] (sum_f) -- (inertial);
		\draw [->] (sum_d) -- node [pos=0.9] {$-$} node [pos=0.5] {$\vect d$} (sum_i);
		\draw [->] (d_b) -- (sum_d);
		\draw [->] (d_c) -- ++(-6em,0) -- (sum_d);
		\draw [->] (d_g) -| (sum_d);
		\draw [->] (inertial) -- node [pos=0.35] {$\ddq_m$} node [name=ddq, pos=0.65,inner sep=0] {}  (ddq2dq);
		\draw [->] (ddq2dq) -- node [pos=0.35] {$\dq_m$} node [name=dq, pos=0.65,inner sep=0] {}  (dq2q);
		\draw [->] (dq2q) -- node [name=q, pos=0.2,inner sep=0] {} node [pos=0.6] {$\q_m$}  (output);

		\draw [->] (ddq) |- (d_b);
		\draw [->] (dq) |- (d_c);
		\draw [->] (q) |- (d_g);

		\draw [->] (dq) |- (dq2f);
		\draw [->] (dq2f) -| node [pos=0.9] {$-$} (sum_f);

		\draw [->] (iq_d) -- node[pos=0.3] {$\qd_m$} node [name=q_d, pos=0.65, inner sep=0] {} (sum_e);
		\draw [->] (sum_e) -- (controller);
		\draw [->] (controller) -- (sum_dd);
		\draw [->] ([yshift=0.6cm]controller_ff) -| node [pos=0.85] {$\hat{\vect d}$} (sum_dd);
		\draw [->] (q) -- ++(0,-2.5) -| node [pos=0.9] {$-$} (sum_e);

		\draw [->] (q_d) |- ([yshift=-0.6cm]controller_ff.west);
		\draw [->] (dq_d) -- node[pos=0.1] {$\dqd_m$} (dq_d -| controller_ff.west);
		\draw [->] (ddq_d) -- node[pos=0.1] {$\ddqd_m$} (ddq_d -| controller_ff.west);
	\end{tikzpicture}
	}
	\caption{open loop feedforward $\vect d$ compensation}
	\label{fig:open-loop}
\end{figure}

\subsection{PD + gravity compensation}

Let us consider again the simplified dynamics model \autoref{eq:simplified-dynamics} and we try to define a control law based on it to hold the given pose $\bar \q$.
To design a proper control law we will exploit the \textbf{Lyapunov method}\index{Lyapunov method}
Let us start defining the error function as

\[
	\qe(t) = \bar \q - \q(t)
\]

and the \textbf{Lyapunov function}

\[
	V(\qe, \dq) = \frac{1}{2} \dq^\trans \matr B(\q) \dq + \frac{1}{2} \qe^\trans \matr K_P \qe
\]

with $\matr K_P > 0$ and symmetrical.

\begin{align*}
    \dot V(\dq, \qe) &= \dq^\trans \matr B(\q) \ddq + \frac{1}{2} \dq^\trans \dot{\matr B}(\q) \dq - \dq^\trans \matr K_P \tilde \q \\
	\text{using \ref{eq:simplified-dynamics}}\qquad
    &= \dq^\trans \left( \vect \tau - \matr C(\q,\dq)\dq -\vect g(\q) \right) + \frac{1}{2} \dq^\trans \dot{\matr B}(\q) \dq - \dq^\trans \matr K_P \tilde \q \\
	&= \frac{1}{2} \dq^\trans \left( \dot{\matr B}(\q) - 2\matr C(\q,\dq) \right) \dq + \dq^\trans \left( \vect \tau -\vect g(\q) - \matr K_P \tilde \q \right) \\
	\intertext{as we saw in \autoref{subsec:matrix-db-2c} the first term is equal to zero}
    &= \dq^\trans \left( \vect \tau -\vect g(\q) - \matr K_P \tilde \q \right)
\end{align*}

if we impose the control law

\begin{equation}
    \vect \tau = \vect g(\q) + \matr K_P \tilde \q - \matr K_D\dq \label{eq:pd-g-control-law}
\end{equation}

with $\matr K_D > 0$ and symmetrical, so $\dot V$ became

\[
	\dot V(\dq, \qe) = - \dq^\trans \matr K_D \dq
\]

the function $\dot V(\dq, \qe)$ is semi-definite negative, but not definite negative (see the possible state $\dq = 0, \qe \in \mathbb{R}$), so we have to study furthermore the asymptotically stability of the equilibrium $\dq=0$.
We consider the dynamic system from \autoref{eq:simplified-dynamics} at the equilibrium $\dq=0$ with the control law from \autoref{eq:pd-g-control-law}

\[
	\matr{B}(\q)\ddq + \matr{C}(\q,\dq)\dq + \vect{g}(\q) = \vect g(\q) + \matr K_P \tilde \q - \matr K_D\dq
\]

and we get

\[
	\matr K_P \tilde \q = 0 \implies \tilde \q = 0
\]

then for the \textbf{Krasowski - La Salle Lemma} we can state that the system with the control law from \autoref{eq:pd-g-control-law} is globally asyntotically stable with the unique equilibrium in $\q = \bar \q$.
This result is valid only if gravity contribution $\vect g(\q)$ is perfectly compensated from the designed control law.

You can see the implemented control system in the \autoref{fig:pd-gravity}.

\begin{nb}with this kind of regulator we do not have control on the time history with which the error $\tilde \q(t)$ goes to zero, so this way is not practicable if we want track a trajectory\end{nb}

\begin{figure}[htb]
	\centering
	%\resizebox{\textwidth}{!}{
	\begin{tikzpicture}
		\node [input] (iq_d) {};

		\node [sum, right=1cm of iq_d] (sum_e) {};
		\node [block, right=0.6cm of sum_e] (kp) {$\matr K_P$};
		\node [sum, right=0.6cm of kp] (sum_d) {};
		\node [sum, right=0.6cm of sum_d] (sum_g) {};
		\node [block, right=1cm of sum_g] (robot) {$Robot$};
		\node [block, above left=0.6cm and -1cm of robot] (kd) {$\matr K_D$};
		\node [block, below left=0.6cm and -1cm of robot] (g) {$\vect g(\cdot)$};

		\node [output, right=1cm of robot, yshift=0.3cm] (odq) {};
		\node [output, right=1cm of robot, yshift=-0.3cm] (oq) {};

		\draw [->] (iq_d) -- node[pos=0.2] {$\bar{\q}$} (sum_e);

		\draw [->] (sum_e) -- (kp);
		\draw [->] (kp) -- (sum_d);
		\draw [->] (sum_d) -- (sum_g);
		\draw [->] (sum_g) -- node {$\vect \tau$} (robot);

		\draw [->] (robot.east |- odq) -- node [pos=0.7] {$\dq$} node [spy, name=dq, pos=0.3] {}  (odq);
		\draw [->] (robot.east |- oq) -- node [pos=0.7] {$\q$} node [spy, name=q, pos=0.3] {} (oq);

		\draw [->] (q) |- (g);
		\draw [->] (g) -| (sum_g);

		\draw [->] (dq) |- (kd);
		\draw [->] (kd) -| node[pos=0.9] {$-$} (sum_d);
		\draw [->] (q) -- ++(0,-2.5) -| node[pos=0.95] {$-$} (sum_e);
	\end{tikzpicture}
	%}
	\caption{Closed loop with PD and gravity compensation}
	\label{fig:pd-gravity}
\end{figure}

\subsection{Inverse dynamics control}

Let us try to solve the problem of the trajectory tracking.
we rewrite the \autoref{eq:simplified-dynamics} in the form

\[
	\matr{B}(\q)\ddq + \vect n(\q,\dq) = \vect \tau
\]

with

\[
	\vect n(\q,\dq) = \matr{C}(\q,\dq)\dq + \vect{g}(\q)
\]

If $\matr B(\q)$ is full rank for each configuration of the manipulator we can define the control law called \textbf{inverse dynamics}\index{inverse dynamics}

\[
	\vect \tau = \matr{B}(\q)\vect y + \vect n(\q,\dq)
\]

so, if the system knowledge is perfect, this law impose the dynamics $\ddq = \vect y$;
from the extern the overall system appears as a double integrator.

Now we can design a control law for the function $\vect y$, a valid choice can be a \textbf{decoupled PD controller}\index{decoupled PD controller}

\begin{equation}
    \vect y = \matr K_P \qe + \matr K_I \dqe + \ddqd\label{eq:inverse-dynamics-control-law}
\end{equation}

that imposes the error dynamics

\[
	\ddqe + \matr K_D \dqe + \matr K_P \qe = 0
\]

then, the error $\qe$ is characterized by a second order dynamics that can be arbitrarily assigned by suitable choice of the parameters of the diagonal matrices $\matr K_P$ and $\matr K_I$.
This allows us to use this technique to track an assigned trajectory.

You can see the implementation of this control in \autoref{fig:inverse-dynamics-control}.

\begin{nb}this technique requires perfect knowledge of the dynamic model, which might be difficult in practice\end{nb}

\begin{figure}[htb]
	\centering
	\resizebox{\textwidth}{!}{
	\begin{tikzpicture}
		\node [input] (iq_d) {};
		\node [input, above=1.5cm of iq_d] (idq_d) {};
		\node [input, above=1.5cm of idq_d] (iddq_d) {};

		\node [sum, right=1.5cm of iq_d] (sum_e) {};
		\node [sum, right=0.8cm of idq_d] (sum_de) {};

		\node [block, right=1cm of sum_e] (kp) {$\matr K_P$};
		\node [block] at (sum_de -| kp) (kd) {$\matr K_D$};

		\node [spy, right=0.5cm of kd] (bend) {};
		\node [sum, right=1.5cm of kd] (sum_y) {};

		\node [block, right=1cm of sum_y] (b) {$\matr B(\cdot)$};
		\node [sum, right=1cm of b] (sum_t) {};
		\node [block, right=1cm of sum_t] (robot) {Robot};

		\node [block, below=0.5cm of robot] (n) {$\vect n(\cdot,\cdot)$};

		\node [output, right=1.5cm of robot, yshift=0.3cm] (odq) {};
		\node [output, right=1.5cm of robot, yshift=-0.3cm] (oq) {};

		\node [node, below=0.3cm of n, xshift=0.4cm] (n_q) {};
		\node [node, below=0.6cm of n, xshift=-0.4cm] (n_dq) {};
		\node [node] at (n_q -| b) (b_q) {};

		\draw [->] (iq_d) -- node [pos=0.2] {$\qd$} (sum_e);
		\draw [->] (idq_d) -- node [pos=0.3] {$\dqd$} (sum_de);
		\draw [->] (iddq_d) -- node [pos=0.05] {$\ddqd$} (bend |- iddq_d) -- (sum_y);

		\draw [->] (sum_e) -- node [pos=0.2] {$\qe$} (kp);
		\draw [->] (sum_de) -- node [pos=0.2] {$\dqe$} (kd);

		\draw [->] (kp) -- (bend |- kp) -- (sum_y);
		\draw [->] (kd) -- (sum_y);

		\draw [->] (sum_y) -- node {$\vect y$} (b);
		\draw [->] (b) -- (sum_t);
		\draw [->] (sum_t) -- node {$\vect \tau$} (robot);

		\draw [->] (robot.east |- odq) -- node [pos=0.8] {$\dq$} node [node, name=dq, pos=0.6] {} (odq);
		\draw [->] (robot.east |- oq) -- node [pos=0.8, below] {$\q$} node [node, name=q, pos=0.3] {} (oq);

		\draw [->] (n) -| (sum_t);

		\draw [->] (q) |- (n_q) -- (b_q) -| node [pos=0.95] {$-$} (sum_e);
		\draw [->] (dq) |- (n_dq)  -| node [pos=0.95] {$-$} (sum_de);

		\draw [->] (n_q) -- (n_q |- n.south);
		\draw [->] (n_dq) -- (n_dq |- n.south);
		\draw [->] (b_q) -- (b_q |- b.south);
	\end{tikzpicture}
	}
	\caption{Closed loop with inverse dynamics control}
	\label{fig:inverse-dynamics-control}
\end{figure}

\subsubsection{Taking into account the uncertainty}\label{subsubsec:inverse-dynamics-robust-control}

As we saw in above the inverse dynamics control required perfect knowledge of the dynamics model of the robot, this is unrealistic in real robots, so we have to take into account the \textbf{model uncertainty}\index{model!uncertainty}.

Let us consider a more realist control law

\[
	\vect \tau = \Bs(\q) \vect y + \ns(\q,\dq)
\]

so the compensated system become

\[
	\B(\q)\ddq + \n(\q,\dq) = \Bs(\q) \y + \ns(\q,\dq)
\]

Let us define the \textbf{uncertainty} as

\[
	\Be(\q) = \Bs(\q) - \B(\q), \qquad
	\ner(\q,\dq) = \ns(\q, \dq) - \n(\q, \dq)
\]

still under the assumption that $\B(\q)$ is invertible, for $\ddq$ we can write

\[
	\ddq = \vect y - \vect \eta
\]

where

\[
	\vect\eta = \left( \I - \B^{-1} \Bs  \right)\y - \B^\inv \ner(\q,\dq)
\]

If we adopt the same control law we saw before in \autoref{eq:inverse-dynamics-control-law}, the error dynamic become

\[
	\ddqe + \matr K_D \dqe + \matr K_P \qe = \vect\eta
\]

the system still nonlinear, so we have to add in addiction to the PD controller a nonlinear term, function of the error to improve the robustness of the final system.

Let us define the second order derivative of the error

\[
	\ddqe = \ddqd - \ddq = \ddqd - \y + \vect \eta
\]

we define a new system whose state are the errors

\[
	\vect \xi = \begin{bmatrix} \qe^\trans \\ \dqe^\trans \end{bmatrix}
\]

and the dynamics is defined by

\[
	\dot{\vect\xi} = \matr H \vect\xi + \matr D \left( \ddqd - \y + \vect\eta \right)
\]

with

\[
	\matr H = \begin{bmatrix}\0&\I\\\0&\0\end{bmatrix} \in \mathbb{R}^{2n \times 2n}, \qquad
	\matr D = \begin{bmatrix}\0\\\I\end{bmatrix} \in \mathbb{R}^{2n \times n}
\]

Before we go any further, we need to characterize the uncertainty with three assumptions

\begin{itemize}
	\item $\sup_{t\ge0}\norm{\ddqd} < Q_M < \infty \qquad \forall \ddqd$

	This assumption requires that the required acceleration is not infinite.
	It is obviously always verified, because a planned trajectory will never require an unlimited acceleration.

	\item $\norm{\I - \B^\inv \Bs} \le \alpha < 1 \qquad \forall \q$

	A matrix $\B$ is definite positive and it is lower and upper bound, so the following equation is always valid
	\[ 0 < B_m \le \norm{\B^\inv} \le B_M < \infty \]
	then, we can impose
 	\[ \Bs = \frac{2}{B_M+B_m}\I \]
	that always satisfy the assumption
	\[ \norm{\I - \B^\inv \Bs} \le \frac{B_M-B_m}{B_M+B_m} < 1 \]
	\begin{nb}$\Bs = \B \implies \alpha = 0$\end{nb}

	\item $\norm{\ner} \le \Phi(\norm{\vect\xi}) < \infty \qquad \forall \q,\dq$

	We can choose the form
	\[ \Phi(\norm{\vect\xi}) = \alpha_0 + \alpha_1 \norm{\vect\xi} + \alpha_2 \norm{\vect\xi}^2 \]
\end{itemize}

We add a term to the control law \autoref{eq:inverse-dynamics-control-law}

\[
	\y = \K_P \qe + \K_I \dqe + \ddqd + \vect w
\]

now we consider the error dynamics with this control law

\begin{align*}
    \dot{\vect\xi} &= \matr H \vect\xi + \matr D \left(\vect\eta - \K_P \qe - \K_I \dqe - \vect w  \right) \\
	&= \tilde{\matr H} \vect\xi + \matr D \left(\vect\eta - \vect w \right)
\end{align*}

defining $\K = \begin{bmatrix}\K_P & \K_D\end{bmatrix}$ with

\[
	\tilde{\matr H} = (\matr H - \matr D \K) =
	\begin{bmatrix} \0&\I \\ - \K_P & \K_D \end{bmatrix}
\]

\begin{nb}all the eigenvalues of $\tilde{\matr H}$ are negative\end{nb}

Now, we need to design a control law for $\vect w$, and to do this we will use the \textbf{Lyapunov method}.
Consider the following \textbf{Lyapunov function} candidate

\[
	V(\vect\xi) = \vect\xi^\trans \matr Q \vect\xi > 0, \qquad \forall \vect\xi \div \vect 0
\]

where $\matr Q$ is symmetric positive definite matrix.

\begin{align*}
    \dot{V} &= \dot{\vect\xi}^\trans \matr Q \vect\xi + \vect\xi^\trans \matr Q \dot{\vect\xi} \\
    &= ( \vect\xi^\trans \tilde{\matr H}^\trans + \left(\vect\eta - \vect w \right)^\trans \matr D^\trans) \matr Q \vect\xi +
    \vect\xi^\trans \matr Q (\tilde{\matr H} \vect\xi + \matr D \left(\vect\eta - \vect w \right)) \\
	&= \vect\xi^\trans \left( \tilde{\matr H}^\trans \matr Q + \matr Q \tilde{\matr H} \right) \vect\xi +
    \left(\vect\eta - \vect w \right)^\trans \matr D^\trans \matr Q \vect\xi +
    \vect\xi^\trans \matr Q \matr D \left(\vect\eta - \vect w \right) \\
    \intertext{transposing the second element because it is a scalar}
	&= \vect\xi^\trans \left( \tilde{\matr H}^\trans \matr Q + \matr Q \tilde{\matr H} \right) \vect\xi +
    2 \vect\xi^\trans \matr Q \matr D \left(\vect\eta - \vect w \right)
    \intertext{set $\vect z = \matr D^\trans \matr Q \vect\xi$ and $\tilde{\matr H}^\trans \matr Q + \matr Q \tilde{\matr H} = -\matr P$}
    &= - \vect\xi^\trans \matr P \vect\xi +
    2 \vect z^\trans \left(\vect\eta - \vect w \right)
\end{align*}

\begin{nb}because all eigenvalues of $\tilde{\matr H}$ are negative for any $\matr P$ positive definite symmetrical matrix also the solution $\matr Q$ is a positive definite symmetrical matrix\end{nb}

Let us analyze the derivative Lyapunov function, the first element $- \vect\xi^\trans \matr P \vect\xi$ is always negative, so we need to analyze the second term.
If $\vect\xi \in \ker(\matr D^\trans \matr Q)$, then $\vect z = 0$, so the system is asymptotically stable, in the other case we have to define a control function $\vect w$ that make the second term negative.
From

\[
	\vect w = \rho \frac{\vect z}{\norm{\vect z}}
\]

we get

\[
	\vect z^\trans \left(\vect\eta - \vect w \right) =
	\vect z^\trans \left(\vect\eta - \rho \frac{\vect z}{\norm{\vect z}} \right) =
	\vect z^\trans \vect\eta - \rho \frac{\vect z^\trans \vect z}{\norm{\vect z}} \le \norm{\vect z}\norm{\vect\eta}-\rho\norm{\vect z} =
	\norm{\vect z}(\norm{\vect\eta} - \rho)
\]

so, if $\rho > \norm{\vect\eta}$ the globally asymptotically stability for the system is guaranteed.
Looking for define a function $\rho$ exploiting the assumptions

\begin{multline*}
    \norm{\vect\eta} \le
    	\norm{\I - \B^\inv \Bs} (\norm{\ddqd} + \norm{\K}\norm{\vect\xi} + \norm{\vect w} + \norm{\B^\inv}\norm{\ner}) \\
    	\le \alpha Q_M + \alpha \norm{\K} \norm{\vect\xi} + \alpha \rho + B_M \Phi(\norm{\vect\xi}) < \rho
\end{multline*}

so

\[
	\rho \ge \frac{1}{1-\alpha} \left(\alpha Q_M + \alpha \norm{\K} \norm{\vect\xi} + B_M \Phi(\norm{\vect\xi}) \right)
\]

under the assumption that $\Phi(\norm{\vect\xi})$ has the form $\alpha_0 + \alpha_1 \norm{\vect\xi} + \alpha_2 \norm{\vect\xi}^2$ we can chose

\[
	\rho(\norm{\vect \xi}) = \beta_0 + \beta_1 \norm{\vect\xi} + \beta_2 \norm{\vect\xi}^2
\]

with

\[
	\beta_0 \ge \frac{\alpha Q_M + \alpha_0 B_M}{1 - \alpha}, \qquad
	\beta_1 \ge \frac{\alpha \norm{\K} + \alpha_1 B_M}{1 - \alpha}, \qquad
	\beta_2 \ge \frac{\alpha_2 B_M}{1 - \alpha}
\]

this control law guarantees a globally asymptotically stability of the system.

So the overall control law is composed by three terms

\begin{itemize}
	\item $\Bs(\q)\y + \ns(\q,\dq)$ \\
	approximately compensated for the nonlinear terms

	\item $\K_P\qe + \K_D\dqe + \ddqd$ \\
	stabilizes the nominal dynamic system in the error

	\item $\vect w = \rho(\norm{\vect \xi}) \frac{\vect z}{\norm{\vect z}}$ \\
	gives robustness, counteracting the uncertainty
\end{itemize}

A further improvement can be done, in order to avoid high frequency switching of the control variable, called \textbf{chattering}\index{chattering}, the third term can be changed to

\[
	\vect w =
	\begin{cases}
		\rho(\norm{\vect \xi}) \frac{\vect z}{\norm{\vect z}} & \norm{\vect z} \ge \epsilon \\
		\rho(\norm{\vect \xi}) \frac{\vect z}{\epsilon} & \norm{\vect z} < \epsilon
	\end{cases}
\]

\begin{figure}[htb]
	\centering
	\resizebox{\textwidth}{!}{
	\begin{tikzpicture}
		\node [input] (iq_d) {};
		\node [input, above=1.5cm of iq_d] (idq_d) {};
		\node [input, above=1.5cm of idq_d] (iddq_d) {};

		\node [sum, right=1.5cm of iq_d] (sum_e) {};
		\node [sum, right=0.8cm of idq_d] (sum_de) {};

		\node [block, right=1cm of sum_e] (kp) {$\matr K_P$};
		\node [block] at (sum_de -| kp) (kd) {$\matr K_D$};

		\node [spy, right=0.5cm of kd] (bend) {};
		\node [sum, right=1.5cm of kd] (sum_y) {};

		\node [block, right=1cm of sum_y] (b) {$\hat{\matr B}(\cdot)$};
		\node [sum, right=1cm of b] (sum_t) {};
		\node [block, right=1cm of sum_t] (robot) {Robot};

		\node [block, below=0.5cm of robot] (n) {$\hat{\vect n}(\cdot,\cdot)$};

		\node [output, right=1.5cm of robot, yshift=0.3cm] (odq) {};
		\node [output, right=1.5cm of robot, yshift=-0.3cm] (oq) {};

		\node [node, below=0.3cm of n, xshift=0.4cm] (n_q) {};
		\node [node, below=0.6cm of n, xshift=-0.4cm] (n_dq) {};
		\node [node] at (n_q -| b) (b_q) {};

		\draw [->] (iq_d) -- node [pos=0.2] {$\qd$} (sum_e);
		\draw [->] (idq_d) -- node [pos=0.3] {$\dqd$} (sum_de);
		\draw [->] (iddq_d) -- node [pos=0.05] {$\ddqd$} (bend |- iddq_d) -- (sum_y);

		\draw [->] (sum_e) -- node [pos=0.2] {$\qe$} node[node, pos=0.6] (qe) {} (kp);
		\draw [->] (sum_de) -- node [pos=0.2] {$\dqe$} node[node, pos=0.4] (dqe) {} (kd);

		\draw [->] (kp) -- (bend |- kp) -- (sum_y);
		\draw [->] (kd) -- (sum_y);

		\draw [->] (sum_y) -- node {$\vect y$} (b);
		\draw [->] (b) -- (sum_t);
		\draw [->] (sum_t) -- node {$\vect \tau$} (robot);

		\draw [->] (robot.east |- odq) -- node [pos=0.8] {$\dq$} node [node, name=dq, pos=0.6] {} (odq);
		\draw [->] (robot.east |- oq) -- node [pos=0.8, below] {$\q$} node [node, name=q, pos=0.3] {} (oq);

		\draw [->] (n) -| (sum_t);

		\draw [->] (q) |- (n_q) -- (b_q) -| node [pos=0.95] {$-$} (sum_e);
		\draw [->] (dq) |- (n_dq)  -| node [pos=0.95] {$-$} (sum_de);

		\draw [->] (n_q) -- (n_q |- n.south);
		\draw [->] (n_dq) -- (n_dq |- n.south);
		\draw [->] (b_q) -- (b_q |- b.south);

		\node [block, above=2cm of sum_y] (w) {$\rho(\norm{\vect\xi})\frac{\vect z}{\norm{\vect z}}$};
		\node [block] at (kd |- w) (t) {$\matr D^\trans \matr Q$};

		\node [node, yshift=0.3cm] at (dqe |- t) (dqe_t) {};
		\node [node, yshift=-0.3cm] at (qe |- t) (qe_t) {};

		\draw [->] (qe) -- (qe_t) -- ++(0,1.2) -| ([xshift=-0.4cm]w);
		\draw [->] (dqe) -- (dqe_t) -- ++(0,1.0) -| ([xshift=0.4cm]w);

		\draw [->] (qe_t) -- (qe_t -| t.west);
		\draw [->] (dqe_t) -- (dqe_t -| t.west);

		\draw [->] (t) -- node {$\vect z$} (w);
		\draw [->] (w) -- node[pos=0.7] {$\vect w$} (sum_y);

	\end{tikzpicture}
	}

	\caption{Closed loop with inverse dynamics robust control}
	\label{fig:inverse-dynamics-robust-control}
\end{figure}

\subsubsection{Adaptive control}

In additional to the inverse dynamics robust control (\autoref{subsubsec:inverse-dynamics-robust-control}) we can consider an adaptive control to compensate the \text{uncertain dynamic parameters}\index{uncertain dynamic parameters}.
As we saw in \autoref{subsec:linearity-in-dynamic-parameters}  the dynamic model can write as

\[
	\matr{B}(\q)\ddq + \matr{C}(\q,\dq)\dq + \vect{g}(\q) = \matr Y(\q,\dq,\ddq)\vect\pi = \vect\tau
\]

where $\vect\pi$ is a suitable constant vector of \text{uncertain dynamic parameters}.

Let us consider the control law

\[
	\vect\tau = \matr{B}(\q)\ddq_r + \matr{C}(\q,\dq)\dq_r + \vect{g}(\q) + \K_D\vect\sigma
\]

where

\[
	\dq_r = \dqd + \matr\Lambda \qe \qquad \ddq_r = \ddqd + \matr\Lambda \dqe
\]

with $\matr\Lambda$ symmetrical positive define matrix (usually diagonal).
If we impose

\[
	\vect\sigma = \dq_r - \dq = \dqe + \matr\Lambda\qe
\]

we get as overall system

\begin{align}
    \matr{B}(\q)\ddq + \matr{C}(\q,\dq)\dq + \vect{g}(\q) &= \matr{B}(\q)\ddq_r + \matr{C}(\q,\dq)\dq_r + \vect{g}(\q) + \K_D \vect\sigma \nonumber \\
    \matr{B}(\q)\ddq + \matr{C}(\q,\dq)\dq  &= \matr{B}(\q)\ddq_r + \matr{C}(\q,\dq)\dq_r + \K_D \vect\sigma \nonumber \\
    \matr{B}(\q) \left( \ddq - \ddq_r \right) + \matr{C}(\q,\dq) \left( \dq - \dq_r \right) &= \K_D \vect\sigma \nonumber \\
    - \matr{B}(\q) \dot{\vect\sigma} - \matr{C}(\q,\dq) \vect\sigma &= \K_D \vect\sigma \nonumber \\
    \matr{B}(\q) \dot{\vect\sigma} + \matr{C}(\q,\dq) \vect\sigma + \K_D \vect\sigma &= \0 \label{eq:adaptive-control-sigma-dynamics}
\end{align}

So let us check the stability of this system using the Lyapunov function

\[
	V(\vect\sigma, \qe) = \frac{1}{2} \vect\sigma^\trans \B(\q) \vect\sigma + \frac{1}{2} \qe^\trans \matr M \qe
\]

$\matr M$ is (as always) a positive definite matrix, so the derivative is

\begin{align*}
    \dot{V} &= \vect\sigma^\trans \B(\q) \dot{\vect\sigma} + \frac{1}{2} \vect\sigma^\trans \dB(\q) \vect\sigma + \qe^\trans \matr M \dqe \\
    \intertext{using $\B(\q) \dot{\vect\sigma}$ from \autoref{eq:adaptive-control-sigma-dynamics}}
	&= \vect\sigma^\trans \left( - \matr{C}(\q,\dq)  - \K_D \right) \vect\sigma + \frac{1}{2} \vect\sigma^\trans \dB(\q) \vect\sigma + \qe^\trans \matr M \dqe \\
	&= - \vect\sigma^\trans \K_D \vect\sigma + \frac{1}{2} \vect\sigma^\trans \left( \dB(\q) - 2 \matr{C}(\q,\dq)\right) \vect\sigma + \qe^\trans \matr M \dqe \\
    \intertext{remembering the property of the matrix  $\dB(\q) - 2 \matr{C}(\q,\dq)$ seen in \autoref{subsec:matrix-db-2c}}
    &= - \vect\sigma^\trans \K_D \vect\sigma + \qe^\trans \matr M \dqe \\
	&= -(\dqe + \matr\Lambda\qe)^\trans \K_D (\dqe + \matr\Lambda\qe) + \qe^\trans \matr M \dqe \\
	&= - \dqe^\trans \K_D \dqe - \qe^\trans \matr\Lambda \K_D \matr\Lambda\qe - 2 \qe^\trans \matr\Lambda \K_D \dqe + \qe^\trans \matr M \dqe \\
	\intertext{choosing $\matr M = 2 \matr\Lambda \K_D$}
    &= - \dqe^\trans \K_D \dqe - \qe^\trans \matr\Lambda \K_D \matr\Lambda\qe \\
\end{align*}

$\dot{V}$ is negative define thus the system is globally asymptotically stable with the equilibrium $\qe = 0, \dqe = 0 $

Now let us consider a control law where the parameters are estimated and exploiting the formulation with the parametric vector we saw above

\begin{align*}
    \vect\tau &= \Bs(\q)\ddq_r + \Cs(\q,\dq)\dq_r + \gs(\q) + \K_D\vect\sigma \\
    &= \matr Y (\q,\dq,\dq_r,\ddq_r)\estimate{\vect\pi} + \K_D\vect\sigma
\end{align*}

the system dynamic model \autoref{eq:adaptive-control-sigma-dynamics} become

\begin{align*}
    \B(\q) \dot{\vect\sigma} + \matr{C}(\q,\dq) \vect\sigma + \K_D \vect\sigma &=
    - \Be(\q) \ddq_r - \Ce(\q,\dq) \dq_r - \error\g(\q) \\
    &= - \matr Y (\q,\dq,\dq_r,\ddq_r)\error{\vect\pi}
\end{align*}

where $\Be, \Ce, \error\g$ are the residual error given by the estimate of the model parameters, and thus the $\matr Y (\q,\dq,\dq_r,\ddq_r)\error{\vect\pi}$ can be seen as the model residual error.

So consider a modified version of the Lyapunov function saw before

\[
	V(\vect\sigma, \qe, \error{\vect\pi}) = \frac{1}{2} \vect\sigma^\trans \B(\q) \vect\sigma + \qe^\trans \matr\Lambda \K_D \qe + \frac{1}{2} \error{\vect\pi}^\trans \K_\pi \error{\vect\pi}
\]

where $\matr M$ is already substituted and $\K_\pi$ is a positive define matrix

\begin{align*}
    \dot V &= \vect\sigma^\trans \B(\q) \dot{\vect\sigma} + \frac{1}{2} \vect\sigma^\trans \dB(\q) \vect\sigma +
    2 \qe^\trans \matr\Lambda \K_D \dqe + \error{\vect\pi}^\trans \K_\pi \dot{\error{\vect\pi}} \\
    \intertext{using $\B(\q) \dot{\vect\sigma}$ from uncertain dynamics model}
    &= \vect\sigma^\trans \left( - \matr{C}(\q,\dq)  - \K_D \right) \vect\sigma - \vect\sigma^\trans \matr Y (\q,\dq,\dq_r,\ddq_r)\error{\vect\pi}
    + \frac{1}{2} \vect\sigma^\trans \dB(\q) \vect\sigma \\ & \hspace{0.6\textwidth}
    + 2 \qe^\trans \matr\Lambda \K_D \dqe + \error{\vect\pi}^\trans \K_\pi \dot{\error{\vect\pi}} \\
    &= - \vect\sigma^\trans \K_D \vect\sigma + \frac{1}{2} \vect\sigma^\trans \left( \dB(\q) - 2 \matr{C}(\q,\dq)\right) \vect\sigma
    - \vect\sigma^\trans \matr Y (\q,\dq,\dq_r,\ddq_r)\error{\vect\pi}  \\ & \hspace{0.6\textwidth}
    + 2 \qe^\trans \matr\Lambda \K_D \dqe + \error{\vect\pi}^\trans \K_\pi \dot{\error{\vect\pi}} \\
    &= - \vect\sigma^\trans \K_D \vect\sigma
    - \vect\sigma^\trans \matr Y (\q,\dq,\dq_r,\ddq_r)\error{\vect\pi} + 2 \qe^\trans \matr\Lambda \K_D \dqe + \error{\vect\pi}^\trans \K_\pi \dot{\error{\vect\pi}} \\
    &= - \vect\sigma^\trans \K_D \vect\sigma
     + 2 \qe^\trans \matr\Lambda \K_D \dqe + \error{\vect\pi}^\trans (\K_\pi \dot{\error{\vect\pi}} -  \matr Y^\trans (\q,\dq,\dq_r,\ddq_r) \vect\sigma) \\
    \intertext{using $\vect\sigma$}
    &= - (\dqe + \matr\Lambda\qe)^\trans \K_D (\dqe + \matr\Lambda\qe)
    + 2 \qe^\trans \matr\Lambda \K_D \dqe + \error{\vect\pi}^\trans (\K_\pi \dot{\error{\vect\pi}} -  \matr Y^\trans (\q,\dq,\dq_r,\ddq_r) \vect\sigma) \\
	&= - \dqe^\trans \K_D \dqe - \qe^\trans \matr\Lambda \K_D \matr\Lambda \qe - 2 \qe^\trans \matr\Lambda \K_D \dqe
    + 2 \qe^\trans \matr\Lambda \K_D \dqe \\ & \hspace{0.5\textwidth}
    + \error{\vect\pi}^\trans (\K_\pi \dot{\error{\vect\pi}} -  \matr Y^\trans (\q,\dq,\dq_r,\ddq_r) \vect\sigma) \\
    &= - \dqe^\trans \K_D \dqe - \qe^\trans \matr\Lambda \K_D \matr\Lambda \qe
    + \error{\vect\pi}^\trans (\K_\pi \dot{\error{\vect\pi}} -  \matr Y^\trans (\q,\dq,\dq_r,\ddq_r) \vect\sigma) \\
	\intertext{if we update the parameters' estimate as $\dot{\estimate{\vect\pi}}=\K_\pi^\inv \matr Y^\trans (\q,\dq,\dq_r,\ddq_r) \vect\sigma=\dot{\error{\vect\pi}}$}
    &= - \dqe^\trans \K_D \dqe - \qe^\trans \matr\Lambda \K_D \matr\Lambda \qe
\end{align*}

$\dot{V} < 0$ thus, the system is globally asymptotically stable with the equilibrium $\qe = 0, \dqe = 0$

So, in summary the overall control law (which you can see in the \autoref{fig:adaptive-control}) is described by the system

\begin{align*}
	\dot{\estimate{\vect\pi}} &= \K_\pi^\inv \matr Y^\trans (\q,\dq,\dq_r,\ddq_r) (\dqe + \matr\Lambda\qe) \\
	\vect\tau &= \matr Y (\q,\dq,\dq_r,\ddq_r)\estimate{\vect\pi} + \K_D (\dqe + \matr\Lambda\qe) \\
\end{align*}

in which we can identify three terms

\begin{itemize}
	\item $\matr Y (\q,\dq,\dq_r,\ddq_r)\estimate{\vect\pi}$ \\
	can be interpreted as an approximate inverse dynamic control

	\item $\K_D (\dqe + \matr\Lambda\qe)$ \\
	has the behaviour of a PD acting on the tracking error

	\item $\K_\pi^\inv \matr Y^\trans (\q,\dq,\dq_r,\ddq_r) (\dqe + \matr\Lambda\qe)$ \\
	update the estimate of parameters in according to a gradient technique.
	The matrix $\K_\pi$ defines the speed of the convergence of the estimate to its asymptotic value.
\end{itemize}

\begin{nb}asymptotically we will not get $\estimate{\vect\pi} \to \vect\pi$, but only $\matr Y(\q,\dq,\dq_r,\ddq_r)(\estimate{\vect\pi} - \vect\pi) \to \0$\end{nb}

\begin{figure}[htb]
	\centering
	\resizebox{\textwidth}{!}{
		\begin{tikzpicture}
			\node [input] (iq_d) {};
			\node [input, above=1.8cm of iq_d] (idq_d) {};
			\node [input, above=1.8cm of idq_d] (iddq_d) {};

			\node [sum, right=1cm of iq_d] (sum_e) {};
			\node [sum, xshift=0.6cm] at (idq_d -| sum_e) (sum_de) {};
			\node [block, right=0.6cm of sum_de] (lambda_de) {$\matr\Lambda$};
			\node [block] at (sum_e -| lambda_de) (lambda_e) {$\matr\Lambda$};

			\node [sum, xshift=0.6cm] at ($(lambda_e.east)!0.5!(lambda_de.east)$) (sum_dqr) {};
			\node [sum] at (iddq_d -| sum_dqr) (sum_ddqr) {};

			\node [sum, right=1cm of sum_dqr] (sum_s) {};

			\node [block, right=1cm of sum_s] (s2dpis) {$\K_\pi^\inv \matr Y^\trans$};
			\node [integrator, right=0.6cm of s2dpis] (dpis2pis) {};
			\node [block, right=0.6cm of dpis2pis] (y) {$\matr Y$};

			\node [block, below=0.5cm of dpis2pis] (kd) {$\K_D$};

			\node [sum, right=0.6cm of y] (sum_t) {};
			\node [block, right=0.6cm of sum_t] (robot) {Robot};

			\node [output, right=1.5cm of robot, yshift=0.3cm] (odq) {};
			\node [output, right=1.5cm of robot, yshift=-0.3cm] (oq) {};

			\draw [->] (iq_d) -- node[pos=0.2] {$\qd$} (sum_e);
			\draw [->] (idq_d) -- node[pos=0.15] {$\dqd$} node[node, name=dqd, pos=0.5] {} (sum_de);
			\draw [->] (iddq_d) -- node[pos=0.05] {$\ddqd$} (sum_ddqr);
			\draw [->] (dqd) |- (sum_dqr);

			\draw [->] (sum_dqr) -- node[node, name=dqr, pos=0.6] {} node[pos=0.3] {$\dq_r$} (sum_s);
			\draw [->] (sum_s) -- node[node, name=s] {} node {$\vect\sigma$} (s2dpis);

			\draw [->] (s2dpis) -- node {$\dot{\estimate{\vect\pi}}$} (dpis2pis);
			\draw [->] (dpis2pis) -- node {$\estimate{\vect\pi}$} (y);
			\draw [->] (y) -- (sum_t);

			\draw [->] (s) |- (kd);
			\draw [->] (kd) -| (sum_t);

			\draw [->] (sum_t) -- node {$\vect\tau$} (robot);

			\draw [->] (robot.east |- odq) -- node [pos=0.8] {$\dq$} node [node, name=dq, pos=0.6] {} (odq);
			\draw [->] (robot.east |- oq) -- node [pos=0.8, below] {$\q$} node [node, name=q, pos=0.3] {} (oq);

			\draw [->] (sum_e) -- node[pos=0.7] {$\qe$} (lambda_e);
			\draw [->] (lambda_e) -| (sum_dqr);

			\draw [->] (sum_de) -- node {$\dqe$} (lambda_de);

			\draw [->] (lambda_de) -| (sum_ddqr);

			\node [node, below=2.5cm of sum_s] (dq_f) {};
			\node [spy, below=0.5cm of dq_f] (q_f) {};

			\draw [->] (dq) |- (dq_f)  -| node[pos=0.95] {$-$} (sum_de);
			\draw [->] (dq_f) -- node[pos=0.95] {$-$} (sum_s);
			\draw [->] (q) |- (q_f)  -| node[pos=0.95] {$-$} (sum_e);


			\node [node] at ([xshift=-0.6cm]iddq_d -| s2dpis) (s2dpis_ddqr2) {};
			\node [node] at ([xshift=-0.6cm]$(s2dpis.north |- iddq_d)!0!(s2dpis.north)$) (ddqr_1) {};
			\node [node] at ([xshift=-0.2cm]$(s2dpis.north |- iddq_d)!0.25!(s2dpis.north)$) (dqr_1) {};
			\node [spy] at ([xshift=0.2cm]$(s2dpis.north |- iddq_d)!0.5!(s2dpis.north)$) (dq_2) {};
			\node [spy] at ([xshift=0.6cm]$(s2dpis.north |- iddq_d)!0.75!(s2dpis.north)$) (q_2) {};

			\node [spy] at ([xshift=-0.6cm]$(y.north |- iddq_d)!0!(y.north)$) (ddqr_2) {};
			\node [spy] at ([xshift=-0.2cm]$(y.north |- iddq_d)!0.25!(y.north)$) (dqr_2) {};
			\node [node] at ([xshift=0.2cm]$(y.north |- iddq_d)!0.5!(y.north)$) (dq_1) {};
			\node [node] at ([xshift=0.6cm]$(y.north |- iddq_d)!0.75!(y.north)$) (q_1) {};

			\draw [->] (q) |- (q_1) -- (y.north -| q_1);
			\draw [->] (dq) |- (dq_1) -- (y.north -| dq_1);
			\draw [->] (q_1) -- (q_2) -- (y.north -| q_2);
			\draw [->] (dq_1) -- (dq_2) -- (y.north -| dq_2);

			\draw [->] (sum_ddqr) -- node[pos=0.15] {$\ddqe_r$} (ddqr_1) -- (s2dpis.north -| ddqr_1);
			\draw [->] (dqr) |- (dqr_1) -- (s2dpis.north -| dqr_1);
			\draw [->] (ddqr_1) -- (ddqr_2) -- (y.north -| ddqr_2);
			\draw [->] (dqr_1) -- (dqr_2) -- (y.north -| dqr_2);
		\end{tikzpicture}
	}

	\caption{Adaptive control scheme}
	\label{fig:adaptive-control}
\end{figure}

In conclusion the \textbf{adaptive control} offers worse performance than the \textbf{robust control} in presence of model errors, but this first guarantees a more regular control action than the \textbf{robust control}, which are characterized by potentially dangerous high frequency switching.


\section{Control in operational space}

In opposite to the control in the joints space, we can implement the control directly in the operational space (a Cartesian space).

As first difference by the control in the joints space, we will not apply the kinematic inversion, but the measures are actually the result of the direct kinematics computations based (generally) on the joint measures.

\subsection{PD + gravity compensation}

In a cartesian space we can define the error as

\[
	\xe = \xd - \x
\]

Let us consider a Lyapunov function

\[
	V(\xe,\dq) = \frac{1}{2} \dq^\trans\B(\q)\dq + \frac{1}{2}\xe^\trans \K_P \xe
\]

with $\K_P$ symmetric positive definite matrix

\begin{align*}
    \dot V &= \dq^\trans \B(\q) \ddq + \frac{1}{2} \dq^\trans \dB(\q) \dq + \dxe^\trans \matr K_P \xe \\
	\intertext{exploiting the \textbf{analytic Jacobian}\index{analytic Jacobian} we have $\dxe=\dx=-\J_A(\q)\dq$}
	&= \dq^\trans \B(\q) \ddq + \frac{1}{2} \dq^\trans \dB(\q) \dq - \dq^\trans \J_A^\trans(\q)\K_P \xe \\
    \intertext{replacing $\B\ddq$ with the \autoref{eq:simplified-dynamics}}
	&= \dq^\trans \left( \vect\tau - \C(\q,\dq)\dq - \g(\q) \right) + \frac{1}{2} \dq^\trans \dB(\q) \dq - \dq^\trans \J_A^\trans(\q)\K_P \xe \\
	&= \frac{1}{2} \dq^\trans \left(\dB(\q) - 2\C(\q,\dq) \right) \dq + \dq^\trans \left( \vect\tau - \g(\q)  - \J_A^\trans(\q)\K_P \xe \right) \\
	\intertext{with the property we saw in \autoref{subsec:matrix-db-2c} we can eliminate the first term}
	&= \dq^\trans \left( \vect\tau - \g(\q)  - \J_A^\trans(\q)\K_P \xe \right) \\
    \intertext{consider the control law $\vect\tau = \g(\q) + \J_A^\trans(\q) \K_P \xe - \J_A^\trans(\q) \K_D \J_A(\q) \dq$}
	&= \dq^\trans \left( \g(\q) + \J_A^\trans(\q) \K_P \xe - \J_A^\trans(\q) \K_D \J_A(\q) \dq - \g(\q)  - \J_A^\trans(\q)\K_P \xe \right) \\
	&= - \dq^\trans \J_A^\trans(\q) \K_D \J_A(\q) \dq
\end{align*}

we can state $\dot V \le 0$ ($\dot V = 0$ for $\dq=0, \forall \xe \in \Real $) so let us check the system trajectory.
The dynamics model (\autoref{eq:simplified-dynamics}) with the control law become

\[
	\matr{B}(\q)\ddq + \matr{C}(\q,\dq)\dq = \J_A^\trans(\q) \K_P \xe - \J_A^\trans(\q) \K_D \J_A(\q) \dq
\]

evaluated in the equilibrium $\dq = 0, \ddq = 0$

\[
	\J_A^\trans(\q) \K_P \xe = \0
\]

so, if the Jacobian is full rank the only solution is $\xe = 0$, thus the system is globally asymptotically stable with the equilibrium $\xd = \x$.

\begin{figure}[htb]
	\centering
	%\resizebox{\textwidth}{!}{
	\begin{tikzpicture}
		\node [input] (iq_d) {};

		\node [sum, right=1cm of iq_d] (sum_e) {};
		\node [block, right=0.6cm of sum_e] (kp) {$\matr K_P$};
		\node [sum, right=0.6cm of kp] (sum_d) {};
		\node [block, right=0.6cm of sum_d] (ja_t) {$\J_A^\trans(\cdot)$};
		\node [sum, right=0.6cm of ja_t] (sum_g) {};
		\node [block, right=1cm of sum_g] (robot) {$Robot$};
		\node [block, above=0.6cm of ja_t] (kd) {$\matr K_D$};
		\node [block, right=1.5cm of kd] (ja) {$\J_A(\cdot)$};
		\node [block, below left=0.6cm and -1cm of robot] (g) {$\vect g(\cdot)$};

		\node [output, right=1cm of robot, yshift=0.3cm] (odq) {};
		\node [output, right=1cm of robot, yshift=-0.3cm] (oq) {};

		\node [block, below=1.5cm of kp] (k) {$\vect k(\cdot)$};


		\node [node] at (k -| ja_t) (q_f) {};

		\draw [->] (iq_d) -- node[pos=0.2] {$\xd$} (sum_e);

		\draw [->] (sum_e) -- node {$\xe$} (kp);
		\draw [->] (kp) -- (sum_d);
		\draw [->] (sum_d) -- (ja_t);
		\draw [->] (ja_t) -- (sum_g);
		\draw [->] (sum_g) -- node {$\vect \tau$} (robot);

		\draw [->] (robot.east |- odq) -- node [pos=0.8] {$\dq$} node [node, name=dq, pos=0.6] {} (odq);
		\draw [->] (robot.east |- oq) -- node [pos=0.8, below] {$\q$} node [node, name=q, pos=0.3] {} (oq);

		\node [node] at (q |- g) {};
		\draw [->] (q |- g) -- (g);
		\draw [->] (g) -| (sum_g);

		\draw [->] (q) -- +(0,1.2) -| (ja);

		\draw [->] (dq) |- (ja);
		\draw [->] (ja) -- node {$\dx$} (kd);
		\draw [->] (kd) -| node[pos=0.9] {$-$} (sum_d);
		\draw [->] (k) -| node[pos=0.2] {$\xs$} node[pos=0.95] {$-$} (sum_e);

		\draw [->] (q) |- (k);
		\draw [->] (q_f) -- (ja_t);
	\end{tikzpicture}
	%}
	\caption{PD and gravity compensation in the operational space}
	\label{fig:pd-gravity-operational}
\end{figure}